---
name: superpowers-debugging
description: 系统化调试。遇到任何Bug、测试失败或意外行为时使用，在提出修复方案前必须先找到根本原因。
---

# 系统化调试

## 核心原则

随机修复浪费时间并创造新Bug。快速补丁掩盖底层问题。

```
铁律：没有根因分析，就不能提出修复
```

如果没完成阶段1，就不能提出修复方案。

## 何时使用

用于任何技术问题：
- 测试失败
- 生产Bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

**特别是当：**
- 时间紧迫（紧急情况让人想猜测）
- "快速修一下"看起来很明显
- 已经尝试了多个修复
- 上一个修复没生效

## 四个阶段

必须完成每个阶段才能进入下一个。

### 阶段1：根因调查

**在尝试任何修复前：**

1. **仔细阅读错误信息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 记录行号、文件路径、错误代码

2. **稳定复现**
   - 能可靠触发吗？
   - 确切步骤是什么？
   - 每次都发生吗？
   - 如果无法复现 → 收集更多数据，不要猜测

3. **检查最近的变更**
   - 什么改变可能导致这个问题？
   - Git diff，最近提交
   - 新依赖、配置变更
   - 环境差异

4. **多组件系统中收集证据**

   **当系统有多个组件时（CI → 构建 → 签名，API → 服务 → 数据库）：**

   **在提出修复前，添加诊断日志：**
   ```
   对于每个组件边界：
     - 记录进入组件的数据
     - 记录离开组件的数据
     - 验证环境/配置传播
     - 检查每层的状态

   运行一次收集证据，显示在哪里断开
   然后分析证据识别失败的组件
   然后调查那个特定组件
   ```

5. **追踪数据流**

   **当错误在调用栈深处时：**
   - 坏值从哪里来？
   - 什么调用了这个并传入坏值？
   - 继续向上追踪直到找到源头
   - 在源头修复，不是在症状处

### 阶段2：模式分析

**在修复前找到模式：**

1. **找到工作示例**
   - 在同一代码库中找到类似的工作代码
   - 什么类似的东西是正常工作的？

2. **与参考对比**
   - 如果实现某个模式，完整阅读参考实现
   - 不要略读 - 读每一行
   - 完全理解模式后再应用

3. **识别差异**
   - 工作的和损坏的之间有什么不同？
   - 列出每一个差异，无论多小
   - 不要假设"那不可能重要"

4. **理解依赖**
   - 这需要什么其他组件？
   - 什么设置、配置、环境？
   - 它做了什么假设？

### 阶段3：假设与测试

**科学方法：**

1. **形成单一假设**
   - 清楚陈述："我认为X是根因，因为Y"
   - 写下来
   - 要具体，不要模糊

2. **最小测试**
   - 做最小可能的改变来测试假设
   - 一次一个变量
   - 不要同时修多个东西

3. **继续前验证**
   - 有效？是 → 阶段4
   - 无效？形成新假设
   - 不要在上面叠加更多修复

4. **当你不知道时**
   - 说"我不理解X"
   - 不要假装知道
   - 寻求帮助
   - 深入研究

### 阶段4：实现

**修复根因，不是症状：**

1. **创建失败测试用例**
   - 最简单的可能复现
   - 如果可能就自动化测试
   - 如果没有框架就一次性测试脚本
   - 修复前必须有
   - 使用 TDD 技能写正确的失败测试

2. **实现单一修复**
   - 解决识别的根因
   - 一次一个改变
   - 没有"顺便"的改进
   - 没有捆绑的重构

3. **验证修复**
   - 测试现在通过了？
   - 没有其他测试失败？
   - 问题真的解决了？

4. **如果修复无效**
   - 停止
   - 计数：你已经尝试了多少个修复？
   - 如果 < 3：返回阶段1，用新信息重新分析
   - **如果 ≥ 3：停止并质疑架构（下面第5步）**
   - 没有架构讨论不要尝试第4个修复

5. **如果3+修复失败：质疑架构**

   **表明架构问题的模式：**
   - 每个修复在不同地方揭示新的共享状态/耦合/问题
   - 修复需要"大规模重构"来实现
   - 每个修复在其他地方创建新症状

   **停止并质疑基础：**
   - 这个模式从根本上是否合理？
   - 我们是否"因为惯性而坚持"？
   - 是否应该重构架构而不是继续修症状？

   **在尝试更多修复前与用户讨论**

## 红旗 - 停止并遵循流程

如果你发现自己在想：
- "先快速修复，以后再调查"
- "试试改X看看是否有效"
- "添加多个改变，运行测试"
- "跳过测试，我会手动验证"
- "可能是X，让我修一下"
- "我不完全理解但这可能有效"
- "再尝试一次修复"（已经尝试了2+）
- 每个修复在不同地方揭示新问题

**所有这些都意味着：停止。返回阶段1。**

**如果3+修复失败：** 质疑架构（见阶段4.5）

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|------|---------|---------|
| **1. 根因** | 读错误、复现、检查变更、收集证据 | 理解什么和为什么 |
| **2. 模式** | 找工作示例、对比 | 识别差异 |
| **3. 假设** | 形成理论、最小测试 | 确认或新假设 |
| **4. 实现** | 创建测试、修复、验证 | Bug解决，测试通过 |

## 常见借口与现实

| 借口 | 现实 |
|------|------|
| "问题简单，不需要流程" | 简单问题也有根因，流程对简单Bug很快 |
| "紧急情况，没时间走流程" | 系统化调试比猜测-检查的混乱更快 |
| "先试这个，然后调查" | 第一个修复设定模式，从一开始就做对 |
| "修复后再写测试" | 未测试的修复不持久，先测试证明它 |
| "一次多个修复省时间" | 无法隔离什么有效，导致新Bug |

## 真实世界影响

来自调试会话：
- 系统方法：15-30分钟修复
- 随机修复方法：2-3小时混乱
- 首次修复成功率：95% vs 40%
- 引入新Bug：几乎为零 vs 常见
