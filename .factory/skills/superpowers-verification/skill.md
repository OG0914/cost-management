---
name: superpowers-verification
description: 完成前验证。声称工作完成、修复或通过前必须使用，要求运行验证命令并确认输出后才能做任何成功声明。
---

# 完成前验证

## 概述

声称工作完成而没有验证是不诚实，不是效率。

**核心原则：** 证据先于声明，总是如此。

```
铁律：没有新鲜的验证证据，就不能声称完成
```

如果你在这条消息中没有运行验证命令，你不能声称它通过了。

## 验证函数

```
在声称任何状态或表达满意前：

1. 识别：什么命令证明这个声明？
2. 运行：执行完整命令（新鲜的，完整的）
3. 阅读：完整输出，检查退出码，计数失败
4. 验证：输出是否确认声明？
   - 如果否：用证据陈述实际状态
   - 如果是：用证据陈述声明
5. 然后才能：做出声明

跳过任何步骤 = 说谎，不是验证
```

## 常见失败

| 声明 | 需要 | 不够 |
|------|------|------|
| 测试通过 | 测试命令输出：0失败 | 之前的运行，"应该通过" |
| Linter干净 | Linter输出：0错误 | 部分检查，推断 |
| 构建成功 | 构建命令：exit 0 | Linter通过，日志看起来好 |
| Bug已修复 | 测试原始症状：通过 | 代码改了，假设修好了 |
| 回归测试工作 | 红-绿循环已验证 | 测试通过一次 |
| 需求满足 | 逐行清单 | 测试通过 |

## 红旗 - 停止

- 使用"应该"、"可能"、"似乎"
- 验证前表达满意（"太好了！"、"完美！"、"完成！"等）
- 准备提交/推送/PR但没验证
- 依赖部分验证
- 想"就这一次"
- 累了想结束工作
- **任何暗示成功但没运行验证的措辞**

## 借口预防

| 借口 | 现实 |
|------|------|
| "现在应该工作了" | 运行验证 |
| "我很有信心" | 信心 ≠ 证据 |
| "就这一次" | 没有例外 |
| "Linter通过了" | Linter ≠ 编译器 |
| "我累了" | 疲惫 ≠ 借口 |
| "部分检查就够了" | 部分什么都证明不了 |

## 关键模式

**测试：**
```
✅ [运行测试命令] [看到: 34/34 通过] "所有测试通过"
❌ "现在应该通过了" / "看起来正确"
```

**回归测试（TDD红-绿）：**
```
✅ 写 → 运行(通过) → 撤销修复 → 运行(必须失败) → 恢复 → 运行(通过)
❌ "我写了回归测试"（没有红-绿验证）
```

**构建：**
```
✅ [运行构建] [看到: exit 0] "构建通过"
❌ "Linter通过了"（linter不检查编译）
```

**需求：**
```
✅ 重读计划 → 创建清单 → 验证每项 → 报告缺口或完成
❌ "测试通过，阶段完成"
```

## 何时应用

**总是在以下之前：**
- 任何成功/完成声明的变体
- 任何满意表达
- 任何关于工作状态的正面陈述
- 提交、PR创建、任务完成
- 进入下一个任务

**规则适用于：**
- 精确短语
- 转述和同义词
- 成功暗示
- 任何暗示完成/正确的沟通

## 底线

**验证没有捷径。**

运行命令。阅读输出。然后声称结果。

这是不可商量的。

## 验证清单模板

```markdown
## 完成验证

### 测试
- [ ] 运行: `npm test`
- [ ] 结果: X/X 通过
- [ ] 无错误/警告

### 类型检查
- [ ] 运行: `npm run typecheck`
- [ ] 结果: 无错误

### 构建
- [ ] 运行: `npm run build`
- [ ] 结果: exit 0

### 需求
- [ ] 需求1: [已验证如何]
- [ ] 需求2: [已验证如何]
- [ ] 需求3: [已验证如何]

### 手动验证（如适用）
- [ ] 功能1工作正常
- [ ] 功能2工作正常

所有项都已验证通过，工作完成。
```
