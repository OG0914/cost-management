# 包装配置 - 软删除修复

## 问题描述
删除包装配置后，再次创建同名配置时仍然提示"该型号下已存在同名的配置"，即使前端页面上已经看不到该配置。

## 根本原因
系统使用软删除机制（`is_active = 0`），删除的配置仍然保留在数据库中。由于数据库有唯一性约束 `UNIQUE(model_id, config_name)`，即使配置已被软删除，仍然会导致唯一性冲突。

### 数据库约束
```sql
CREATE TABLE packaging_configs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  model_id INTEGER NOT NULL,
  config_name TEXT NOT NULL,
  -- ... 其他字段
  is_active BOOLEAN DEFAULT 1,
  UNIQUE(model_id, config_name)  -- 唯一性约束
);
```

### 问题流程
1. 创建配置"标准包装" → 成功（`is_active = 1`）
2. 删除配置 → 软删除（`is_active = 0`，但 `config_name` 仍为"标准包装"）
3. 再次创建"标准包装" → 失败（违反唯一性约束）

## 解决方案

### 方案选择
有两种可能的解决方案：

**方案1：修改数据库约束（不推荐）**
- 创建部分唯一索引，只对 `is_active = 1` 的记录生效
- 需要修改数据库结构
- SQLite 3.8.0+ 支持部分索引

**方案2：删除时修改配置名称（推荐）**
- 在软删除时，修改配置名称添加删除标记
- 无需修改数据库结构
- 保留完整的历史数据

我们选择方案2，因为它更简单且不需要修改数据库结构。

### 实现细节

#### 修改删除方法
**文件：** `backend/models/PackagingConfig.js`

```javascript
// 删除包装配置（软删除）
static delete(id) {
  const db = dbManager.getDatabase();
  
  // 先获取当前配置信息
  const config = this.findById(id);
  if (!config) {
    throw new Error('配置不存在');
  }
  
  // 软删除时，在配置名称后添加删除标记和时间戳，避免唯一性约束冲突
  const deletedName = `${config.config_name}_deleted_${Date.now()}`;
  
  const stmt = db.prepare(`
    UPDATE packaging_configs
    SET is_active = 0, 
        config_name = ?,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = ?
  `);
  return stmt.run(deletedName, id);
}
```

#### 删除前后对比

**删除前：**
```
id: 1
model_id: 1
config_name: 标准包装
is_active: 1
```

**删除后：**
```
id: 1
model_id: 1
config_name: 标准包装_deleted_1764144669572
is_active: 0
```

## 测试验证

### 测试脚本
创建了测试脚本 `backend/test-packaging-config-delete.js` 验证修复效果。

### 测试流程
1. ✅ 创建测试配置
2. ✅ 检查配置是否存在
3. ✅ 删除配置（软删除）
4. ✅ 检查删除后配置是否还存在（应该不存在）
5. ✅ 尝试创建同名配置（应该成功）
6. ✅ 清理测试数据

### 测试结果
```
=== 测试包装配置删除和重新创建 ===

1. 创建测试配置
   ✓ 配置创建成功，ID: 4

2. 检查配置是否存在
   ✓ 配置检查正确

3. 删除配置（软删除）
   ✓ 配置已删除

4. 检查删除后配置是否还存在
   ✓ 删除后检查正确（不存在）

5. 尝试创建同名配置
   ✓ 同名配置创建成功，ID: 5

6. 清理测试数据
   ✓ 测试数据已清理

=== 所有测试通过 ===
```

## 使用场景

### 场景1：删除后重新创建
```
1. 创建配置"标准包装"
2. 删除配置
   - 数据库中：config_name = "标准包装_deleted_1764144669572"
   - 前端显示：配置已删除（不可见）
3. 再次创建"标准包装"
   - 成功！因为名称不冲突
```

### 场景2：查看历史删除记录
```sql
-- 查看所有删除的配置
SELECT * FROM packaging_configs 
WHERE is_active = 0 
ORDER BY updated_at DESC;

-- 查看特定型号的删除记录
SELECT * FROM packaging_configs 
WHERE model_id = 1 AND is_active = 0
ORDER BY updated_at DESC;
```

### 场景3：恢复删除的配置
如果需要恢复删除的配置，可以：
1. 创建同名的新配置（推荐）
2. 或者手动修改数据库，恢复 `is_active = 1` 并修改 `config_name`

## 优势

1. **无需修改数据库结构**：不需要修改表结构或索引
2. **保留完整历史**：删除的配置仍然保留在数据库中
3. **避免冲突**：通过修改名称避免唯一性约束冲突
4. **时间戳标记**：使用时间戳确保删除标记的唯一性
5. **向后兼容**：不影响现有功能

## 注意事项

1. **删除标记格式**：`原名称_deleted_时间戳`
2. **时间戳精度**：使用毫秒级时间戳（`Date.now()`）
3. **查询过滤**：查询时始终使用 `is_active = 1` 过滤
4. **历史数据**：删除的配置可以通过 `is_active = 0` 查询
5. **不可恢复**：前端不提供恢复功能，只能重新创建

## 相关修改

### 修改的文件
1. ✅ `backend/models/PackagingConfig.js` - 修改 `delete` 方法
2. ✅ `backend/test-packaging-config-delete.js` - 新建测试脚本
3. ✅ `docs/包装配置-重复名称检查.md` - 更新文档
4. ✅ `docs/包装配置-软删除修复.md` - 新建文档

### 影响的功能
- 包装配置删除
- 包装配置创建
- 工序管理页面

## 数据库查询示例

### 查看活跃配置
```sql
SELECT * FROM packaging_configs 
WHERE is_active = 1 
ORDER BY created_at DESC;
```

### 查看删除的配置
```sql
SELECT * FROM packaging_configs 
WHERE is_active = 0 
ORDER BY updated_at DESC;
```

### 查看特定配置的删除历史
```sql
SELECT * FROM packaging_configs 
WHERE config_name LIKE '标准包装%' 
ORDER BY updated_at DESC;
```

### 统计删除的配置数量
```sql
SELECT model_id, COUNT(*) as deleted_count
FROM packaging_configs 
WHERE is_active = 0
GROUP BY model_id;
```

## 未来改进

1. **恢复功能**：提供前端界面恢复已删除的配置
2. **删除历史**：显示配置的删除历史记录
3. **永久删除**：提供永久删除功能（真删除）
4. **批量操作**：支持批量删除和恢复
5. **删除原因**：记录删除原因和操作人

## 相关文档

- [包装配置-重复名称检查.md](./包装配置-重复名称检查.md)
- [工序管理功能说明](./工序管理功能说明.md)
