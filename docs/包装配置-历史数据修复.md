# 包装配置 - 历史数据修复

## 问题总结
虽然我们修改了删除逻辑，在删除时添加删除标记，但数据库中已经存在的旧删除记录没有删除标记，仍然会导致唯一性约束冲突。

## 发现的问题
运行检查脚本后发现：
```
找到 4 个已删除的配置：

ID: 2
  配置名称: C2标准包装  ← 没有删除标记
  是否活跃: 0

ID: 3
  配置名称: C2标准包装  ← 没有删除标记
  是否活跃: 0

ID: 4
  配置名称: 测试配置_1764144669572_deleted_1764144669574  ← 有删除标记
  是否活跃: 0

ID: 5
  配置名称: 测试配置_1764144669572_deleted_1764144669575  ← 有删除标记
  是否活跃: 0
```

## 修复方案

### 1. 检查脚本
创建 `backend/scripts/check-deleted-configs.js` 检查数据库中的删除记录。

**功能：**
- 查询所有 `is_active = 0` 的配置
- 检查哪些配置没有添加删除标记
- 提供修复建议

**使用方法：**
```bash
node backend/scripts/check-deleted-configs.js
```

### 2. 修复脚本
创建 `backend/scripts/fix-deleted-configs.js` 修复历史删除记录。

**功能：**
- 查找所有 `is_active = 0` 且配置名称不包含 `_deleted_` 的记录
- 为这些记录添加删除标记：`原名称_deleted_时间戳_ID`
- 使用事务批量更新
- 验证修复结果

**使用方法：**
```bash
node backend/scripts/fix-deleted-configs.js
```

## 修复过程

### 步骤1：检查问题
```bash
$ node backend/scripts/check-deleted-configs.js

=== 检查已删除的包装配置 ===

找到 4 个已删除的配置：

⚠️  发现 2 个未添加删除标记的配置：
  ID: 2, 名称: C2标准包装
  ID: 3, 名称: C2标准包装

建议运行修复脚本：node backend/scripts/fix-deleted-configs.js
```

### 步骤2：运行修复
```bash
$ node backend/scripts/fix-deleted-configs.js

=== 修复已删除的包装配置 ===

找到 2 个需要修复的配置：
ID: 2, 名称: C2标准包装
ID: 3, 名称: C2标准包装

开始修复...

✓ ID 2: C2标准包装 → C2标准包装_deleted_1764145977770_2
✓ ID 3: C2标准包装 → C2标准包装_deleted_1764145977772_3

修复完成！
  成功: 2 个
  失败: 0 个

✓ 所有配置已成功修复
```

### 步骤3：验证修复
```bash
$ node backend/scripts/check-deleted-configs.js

=== 检查已删除的包装配置 ===

找到 4 个已删除的配置：

✓ 所有已删除的配置都已正确添加删除标记
```

## 修复结果

### 修复前
```sql
SELECT * FROM packaging_configs WHERE is_active = 0;

-- 结果：
-- ID: 2, config_name: C2标准包装, is_active: 0
-- ID: 3, config_name: C2标准包装, is_active: 0
```

### 修复后
```sql
SELECT * FROM packaging_configs WHERE is_active = 0;

-- 结果：
-- ID: 2, config_name: C2标准包装_deleted_1764145977770_2, is_active: 0
-- ID: 3, config_name: C2标准包装_deleted_1764145977772_3, is_active: 0
```

## 验证测试

### 测试场景
1. 删除配置"C2标准包装"
2. 再次创建配置"C2标准包装"

### 测试结果
✅ 修复前：提示"该型号下已存在同名的配置"
✅ 修复后：创建成功

## 技术细节

### 删除标记格式
```
原名称_deleted_时间戳_ID
```

**示例：**
- `C2标准包装_deleted_1764145977770_2`
- `标准包装_deleted_1764145977772_3`

### 为什么添加ID后缀
- 确保唯一性：即使同一时间删除多个同名配置
- 便于追溯：可以通过ID找到原始记录
- 避免冲突：不同ID的配置即使同名也不会冲突

### 事务处理
使用 SQLite 事务确保批量更新的原子性：
```javascript
const updateAll = db.transaction((configs) => {
  for (const config of configs) {
    updateStmt.run(deletedName, config.id);
  }
});
```

## 预防措施

### 1. 代码层面
已修改 `PackagingConfig.delete()` 方法，新的删除操作会自动添加删除标记。

### 2. 定期检查
建议定期运行检查脚本，确保没有遗漏：
```bash
# 添加到定期维护任务
node backend/scripts/check-deleted-configs.js
```

### 3. 数据库备份
在运行修复脚本前，建议备份数据库：
```bash
cp backend/db/cost_analysis.db backend/db/cost_analysis.db.backup
```

## 相关脚本

### 创建的脚本
1. ✅ `backend/scripts/check-deleted-configs.js` - 检查脚本
2. ✅ `backend/scripts/fix-deleted-configs.js` - 修复脚本
3. ✅ `backend/test-packaging-config-delete.js` - 测试脚本

### 脚本用途
- **check-deleted-configs.js**：日常检查，发现问题
- **fix-deleted-configs.js**：一次性修复历史数据
- **test-packaging-config-delete.js**：测试删除和重建功能

## 注意事项

1. **一次性操作**：修复脚本只需运行一次，修复历史数据
2. **新删除操作**：新的删除操作会自动添加删除标记
3. **数据安全**：修复脚本使用事务，确保数据一致性
4. **可回滚**：如有问题，可以从备份恢复

## 未来改进

1. **自动检查**：在应用启动时自动检查并修复
2. **迁移脚本**：将修复逻辑集成到数据库迁移脚本
3. **监控告警**：发现未添加删除标记的记录时发送告警

## 相关文档

- [包装配置-软删除修复.md](./包装配置-软删除修复.md)
- [包装配置-重复名称检查.md](./包装配置-重复名称检查.md)
