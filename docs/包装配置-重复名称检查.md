# 包装配置 - 重复名称检查改进

## 问题描述
在创建包装配置时，如果同一型号下已存在相同名称的配置，会抛出数据库唯一性约束错误：
```
SqliteError: UNIQUE constraint failed: packaging_configs.model_id, packaging_configs.config_name
```

这个错误信息对用户不友好，需要改进错误处理。

## 解决方案

### 1. 改进软删除逻辑
在删除配置时，修改配置名称添加删除标记，避免唯一性约束冲突。

**文件：** `backend/models/PackagingConfig.js`

```javascript
// 删除包装配置（软删除）
static delete(id) {
  const db = dbManager.getDatabase();
  
  // 先获取当前配置信息
  const config = this.findById(id);
  if (!config) {
    throw new Error('配置不存在');
  }
  
  // 软删除时，在配置名称后添加删除标记和时间戳，避免唯一性约束冲突
  const deletedName = `${config.config_name}_deleted_${Date.now()}`;
  
  const stmt = db.prepare(`
    UPDATE packaging_configs
    SET is_active = 0, 
        config_name = ?,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = ?
  `);
  return stmt.run(deletedName, id);
}
```

### 2. 添加预检查方法
在 `PackagingConfig` 模型中添加 `existsByModelAndName` 方法，用于检查配置名称是否已存在。

**文件：** `backend/models/PackagingConfig.js`

```javascript
// 检查配置名称是否已存在
static existsByModelAndName(modelId, configName) {
  const db = dbManager.getDatabase();
  const stmt = db.prepare(`
    SELECT COUNT(*) as count
    FROM packaging_configs
    WHERE model_id = ? AND config_name = ? AND is_active = 1
  `);
  const result = stmt.get(modelId, configName);
  return result.count > 0;
}
```

### 3. 在创建前进行检查
在 `processController` 的 `createPackagingConfig` 方法中，创建配置前先检查名称是否已存在。

**文件：** `backend/controllers/processController.js`

```javascript
// 检查配置名称是否已存在
if (PackagingConfig.existsByModelAndName(model_id, config_name)) {
  return res.status(400).json({
    success: false,
    message: '该型号下已存在同名的配置，请修改配置名称'
  });
}
```

### 4. 改进错误处理
同时改进 catch 块中的错误处理，检查 `error.code` 而不仅仅是 `error.message`。

```javascript
catch (error) {
  console.error('创建包装配置失败:', error);
  
  // 检查是否是唯一性约束错误
  if (error.code === 'SQLITE_CONSTRAINT_UNIQUE' || 
      (error.message && error.message.includes('UNIQUE constraint failed'))) {
    return res.status(400).json({
      success: false,
      message: '该型号下已存在同名的配置，请修改配置名称'
    });
  }
  
  res.status(500).json({
    success: false,
    message: error.message || '创建包装配置失败'
  });
}
```

## 改进效果

### 改进前
用户尝试创建重复名称的配置时，会看到：
```
创建包装配置失败: SqliteError: UNIQUE constraint failed: packaging_configs.model_id, packaging_configs.config_name
```

### 改进后
用户会看到友好的错误提示：
```
该型号下已存在同名的配置，请修改配置名称
```

## 使用场景

### 场景1：创建新配置
用户为型号"ABC-001"创建配置"标准包装"：
1. 第一次创建 → 成功
2. 再次创建同名配置 → 提示"该型号下已存在同名的配置，请修改配置名称"

### 场景2：不同型号可以使用相同配置名
- 型号"ABC-001"可以有配置"标准包装"
- 型号"ABC-002"也可以有配置"标准包装"
- 两者不冲突，因为 `model_id` 不同

### 场景3：软删除后可以重新创建
如果配置被软删除（`is_active = 0`），可以创建同名的新配置。

**实现方式：**
删除时会在配置名称后添加删除标记和时间戳，例如：
- 原始名称：`标准包装`
- 删除后：`标准包装_deleted_1764144669572`

这样既保留了历史数据，又避免了唯一性约束冲突。

## 数据库约束

### 唯一性约束
```sql
CREATE TABLE packaging_configs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  model_id INTEGER NOT NULL,
  config_name TEXT NOT NULL,
  -- ... 其他字段
  UNIQUE(model_id, config_name)
);
```

这个约束确保：
- 同一型号下不能有重复的配置名称
- 不同型号可以有相同的配置名称

## 前端处理

### 错误提示
前端接收到错误响应后，会显示友好的错误消息：

```javascript
try {
  await request.post('/processes/packaging-configs', data);
  ElMessage.success('创建成功');
} catch (error) {
  // 显示错误消息
  ElMessage.error(error.message || '创建失败');
}
```

### 建议改进
可以在前端添加实时验证，在用户输入配置名称时检查是否已存在：

```javascript
// 检查配置名称是否已存在
const checkConfigName = async (modelId, configName) => {
  try {
    const response = await request.get(
      `/processes/packaging-configs/check-name?model_id=${modelId}&config_name=${configName}`
    );
    return response.data.exists;
  } catch (error) {
    return false;
  }
};
```

## 测试验证

### 测试用例1：创建重复配置
```bash
# 第一次创建
POST /api/processes/packaging-configs
{
  "model_id": 1,
  "config_name": "标准包装",
  "pc_per_bag": 10,
  "bags_per_box": 5,
  "boxes_per_carton": 4
}
# 响应：成功

# 第二次创建（相同名称）
POST /api/processes/packaging-configs
{
  "model_id": 1,
  "config_name": "标准包装",
  "pc_per_bag": 12,
  "bags_per_box": 6,
  "boxes_per_carton": 5
}
# 响应：400 Bad Request
# 消息：该型号下已存在同名的配置，请修改配置名称
```

### 测试用例2：不同型号相同名称
```bash
# 型号1创建配置
POST /api/processes/packaging-configs
{
  "model_id": 1,
  "config_name": "标准包装",
  ...
}
# 响应：成功

# 型号2创建相同名称的配置
POST /api/processes/packaging-configs
{
  "model_id": 2,
  "config_name": "标准包装",
  ...
}
# 响应：成功（不同型号，允许重复）
```

## 相关代码

### 修改的文件
1. `backend/models/PackagingConfig.js` - 添加 `existsByModelAndName` 方法
2. `backend/controllers/processController.js` - 添加预检查和改进错误处理

### 影响的功能
- 包装配置创建
- 工序管理页面
- Excel 导入功能（如果导入重复配置）

## 最佳实践

1. **命名规范**：建议使用有意义的配置名称，如"标准包装"、"出口包装"、"简易包装"等
2. **避免重复**：创建前先查看该型号下已有的配置
3. **使用编号**：如果需要多个类似配置，可以使用编号，如"标准包装-1"、"标准包装-2"
4. **软删除恢复**：如果需要恢复已删除的配置，可以创建同名的新配置

## 注意事项

1. **大小写敏感**：配置名称区分大小写，"标准包装"和"标准包装"是不同的
2. **空格处理**：配置名称前后的空格会被保留，建议前端进行 trim 处理
3. **软删除**：删除时会修改配置名称，添加 `_deleted_时间戳` 后缀，避免唯一性约束冲突
4. **历史数据**：删除的配置仍保留在数据库中，可以通过查询 `is_active = 0` 的记录查看
5. **并发问题**：在高并发情况下，预检查和创建之间可能存在竞态条件，但数据库约束会作为最后的保障

## 未来改进

1. **前端实时验证**：在用户输入配置名称时实时检查是否已存在
2. **建议配置名**：根据已有配置自动生成建议的配置名称
3. **配置模板**：提供常用的配置模板，减少重复创建
4. **批量检查**：在 Excel 导入时，批量检查所有配置名称是否重复

## 相关文档

- [工序管理功能说明](./工序管理功能说明.md)
- [包装配置管理](./包装配置管理.md)
